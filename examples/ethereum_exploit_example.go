package main

import (
	"crypto/elliptic"
	"fmt"
	"math/big"

	"slippage/ethereum"
)

// This example shows how to recover the private key of an Ethereum address
// from transactions that use transaction count as nonce

func main() {
	fmt.Println("=== Key Extraction from Ethereum Address with Transaction Count Nonce ===\n")
	fmt.Println("⚠️  This is a real vulnerability!")
	fmt.Println("If transaction count is used as ECDSA nonce,")
	fmt.Println("the private key can be recovered.\n")

	curve := elliptic.P256()

	// Scenario 1: Recovery from two consecutive transactions
	fmt.Println("--- Scenario 1: Recovery from Two Consecutive Transactions ---")
	scenario1_twoTransactions(curve)

	// Scenario 2: Recovery from a single transaction (if we know the nonce)
	fmt.Println("\n--- Scenario 2: Recovery from Single Transaction (Known Nonce) ---")
	scenario2_singleTransaction(curve)

	// Scenario 3: Recovery from multiple transactions
	fmt.Println("\n--- Scenario 3: Recovery from Multiple Transactions ---")
	scenario3_multipleTransactions(curve)
}

// scenario1_twoTransactions recovery from two consecutive transactions
func scenario1_twoTransactions(curve elliptic.Curve) {
	// create an Ethereum address
	address, err := ethereum.NewEthereumAddress(curve)
	if err != nil {
		fmt.Printf("Error: %v\n", err)
		return
	}

	fmt.Printf("Ethereum address created\n")
	fmt.Printf("Original private key: %s\n\n", address.PrivateKey.String())

	// create two consecutive transactions
	// Transaction 1: nonce = 1
	tx1, err := address.SignTransactionWithCounterNonce(
		"0x742d35Cc6634C0532925a3b844Bc9e7595f0bEb",
		big.NewInt(1000000000000000000), // 1 ETH
		[]byte("transfer"),
	)
	if err != nil {
		fmt.Printf("Error in transaction 1: %v\n", err)
		return
	}

	fmt.Printf("Transaction 1 created:\n")
	fmt.Printf("  Nonce: %d\n", tx1.Nonce)
	fmt.Printf("  r: %s\n", tx1.Signature.R.String())
	fmt.Printf("  s: %s\n\n", tx1.Signature.S.String())

	// Transaction 2: nonce = 2
	tx2, err := address.SignTransactionWithCounterNonce(
		"0x742d35Cc6634C0532925a3b844Bc9e7595f0bEb",
		big.NewInt(2000000000000000000), // 2 ETH
		[]byte("transfer"),
	)
	if err != nil {
		fmt.Printf("Error in transaction 2: %v\n", err)
		return
	}

	fmt.Printf("Transaction 2 created:\n")
	fmt.Printf("  Nonce: %d\n", tx2.Nonce)
	fmt.Printf("  r: %s\n", tx2.Signature.R.String())
	fmt.Printf("  s: %s\n\n", tx2.Signature.S.String())

	// extract key from two transactions
	fmt.Println("Starting key extraction...")
	exploit := ethereum.NewEthereumExploit(curve)
	recoveredKey, err := exploit.ExploitFromCounterNonce(tx1, tx2)
	if err != nil {
		fmt.Printf("Error in extraction: %v\n", err)
		return
	}

	fmt.Printf("Recovered key: %s\n", recoveredKey.String())

	// verify
	if recoveredKey.Cmp(address.PrivateKey) == 0 {
		fmt.Println("✓ Key successfully recovered!")
		fmt.Println("✓ Recovered key matches original key")
	} else {
		fmt.Println("✗ Recovered key is incorrect")
		fmt.Printf("  Original key:   %s\n", address.PrivateKey.String())
		fmt.Printf("  Recovered key: %s\n", recoveredKey.String())
	}
}

// scenario2_singleTransaction recovery from a single transaction (if we know the nonce)
func scenario2_singleTransaction(curve elliptic.Curve) {
	// create an address
	address, err := ethereum.NewEthereumAddress(curve)
	if err != nil {
		fmt.Printf("Error: %v\n", err)
		return
	}

	fmt.Printf("Original private key: %s\n", address.PrivateKey.String())

	// create a transaction
	tx, err := address.SignTransactionWithCounterNonce(
		"0x742d35Cc6634C0532925a3b844Bc9e7595f0bEb",
		big.NewInt(500000000000000000), // 0.5 ETH
		[]byte("transfer"),
	)
	if err != nil {
		fmt.Printf("Error: %v\n", err)
		return
	}

	fmt.Printf("Transaction created with nonce: %d\n", tx.Nonce)

	// if we know the nonce (transaction count), we can recover the key directly
	exploit := ethereum.NewEthereumExploit(curve)
	recoveredKey, err := exploit.RecoverPrivateKeyFromEthereumNonce(tx)
	if err != nil {
		fmt.Printf("Error: %v\n", err)
		return
	}

	fmt.Printf("Recovered key: %s\n", recoveredKey.String())

	if recoveredKey.Cmp(address.PrivateKey) == 0 {
		fmt.Println("✓ Key successfully recovered!")
	} else {
		fmt.Println("✗ Recovered key is incorrect")
	}
}

// scenario3_multipleTransactions recovery from multiple transactions
func scenario3_multipleTransactions(curve elliptic.Curve) {
	// create an address
	address, err := ethereum.NewEthereumAddress(curve)
	if err != nil {
		fmt.Printf("Error: %v\n", err)
		return
	}

	fmt.Printf("Original private key: %s\n\n", address.PrivateKey.String())

	// create multiple transactions
	var signatures []*ethereum.TransactionSignature
	for i := 0; i < 5; i++ {
		tx, err := address.SignTransactionWithCounterNonce(
			"0x742d35Cc6634C0532925a3b844Bc9e7595f0bEb",
			big.NewInt(int64(i+1)*100000000000000000), // different values
			[]byte(fmt.Sprintf("transfer_%d", i)),
		)
		if err != nil {
			fmt.Printf("Error in transaction %d: %v\n", i+1, err)
			continue
		}
		signatures = append(signatures, tx)
		fmt.Printf("Transaction %d: nonce=%d\n", i+1, tx.Nonce)
	}

	fmt.Println("\nStarting extraction from multiple transactions...")
	exploit := ethereum.NewEthereumExploit(curve)
	recoveredKeys, err := exploit.ExploitFromMultipleTransactions(signatures)
	if err != nil {
		fmt.Printf("Error: %v\n", err)
		return
	}

	fmt.Printf("\nNumber of recovered keys: %d\n", len(recoveredKeys))
	for i, key := range recoveredKeys {
		fmt.Printf("Key %d: %s\n", i+1, key.String())
		if key.Cmp(address.PrivateKey) == 0 {
			fmt.Printf("  ✓ Key %d is correct!\n", i+1)
		}
	}
}

// demonstrateRealWorldScenario demonstrate a real-world scenario
func demonstrateRealWorldScenario() {
	fmt.Println("\n=== Real-World Scenario: Extraction from Real Transactions ===\n")
	fmt.Println("In the real world:")
	fmt.Println("1. An Ethereum address sends multiple transactions")
	fmt.Println("2. If transaction count is used as ECDSA nonce")
	fmt.Println("3. We can recover the key from any two consecutive transactions")
	fmt.Println("4. This is a serious vulnerability!\n")

	fmt.Println("Solution:")
	fmt.Println("- Always use random and unique nonces")
	fmt.Println("- Use RFC 6979 for deterministic nonce generation")
	fmt.Println("- Never use transaction count as ECDSA nonce")
}
